
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ross.rotor_assembly &#8212; ross 1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>ross 1.0 documentation</span></a></h1>
        <h2 class="heading"><span>ross.rotor_assembly</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for ross.rotor_assembly</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">la</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span> <span class="k">as</span> <span class="nn">las</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">signal</span>
<span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="nn">sio</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Iterable</span>

<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">cycler</span> <span class="k">import</span> <span class="n">cycler</span>

<span class="kn">from</span> <span class="nn">ross.bearing_seal_element</span> <span class="k">import</span> <span class="n">BearingElement</span>
<span class="kn">from</span> <span class="nn">ross.disk_element</span> <span class="k">import</span> <span class="n">DiskElement</span>
<span class="kn">from</span> <span class="nn">ross.shaft_element</span> <span class="k">import</span> <span class="n">ShaftElement</span>
<span class="kn">from</span> <span class="nn">ross.materials</span> <span class="k">import</span> <span class="n">steel</span>
<span class="kn">from</span> <span class="nn">ross.results</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">CampbellResults</span><span class="p">,</span>
    <span class="n">FrequencyResponseResults</span><span class="p">,</span>
    <span class="n">ForcedResponseResults</span><span class="p">,</span>
    <span class="n">ModeShapeResults</span><span class="p">,</span>
<span class="p">)</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Rotor&quot;</span><span class="p">,</span> <span class="s2">&quot;rotor_example&quot;</span><span class="p">]</span>

<span class="c1"># set style and colors</span>
<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s2">&quot;seaborn-white&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="s2">&quot;lines.linewidth&quot;</span><span class="p">:</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="s2">&quot;axes.grid&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="s2">&quot;axes.linewidth&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="s2">&quot;grid.color&quot;</span><span class="p">:</span> <span class="s2">&quot;.9&quot;</span><span class="p">,</span>
        <span class="s2">&quot;grid.linestyle&quot;</span><span class="p">:</span> <span class="s2">&quot;--&quot;</span><span class="p">,</span>
        <span class="s2">&quot;legend.frameon&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="s2">&quot;legend.framealpha&quot;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="n">_orig_rc_params</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">seaborn_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;#4c72b0&quot;</span><span class="p">,</span> <span class="s2">&quot;#55a868&quot;</span><span class="p">,</span> <span class="s2">&quot;#c44e52&quot;</span><span class="p">,</span> <span class="s2">&quot;#8172b2&quot;</span><span class="p">,</span> <span class="s2">&quot;#ccb974&quot;</span><span class="p">,</span> <span class="s2">&quot;#64b5cd&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="Rotor"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor">[docs]</a><span class="k">class</span> <span class="nc">Rotor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A rotor object.</span>

<span class="sd">    This class will create a rotor with the shaft,</span>
<span class="sd">    disk, bearing and seal elements provided.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shaft_elements : list</span>
<span class="sd">        List with the shaft elements</span>
<span class="sd">    disk_elements : list</span>
<span class="sd">        List with the disk elements</span>
<span class="sd">    bearing_seal_elements : list</span>
<span class="sd">        List with the bearing elements</span>
<span class="sd">    w : float, optional</span>
<span class="sd">        Rotor speed. Defaults to 0.</span>
<span class="sd">    sparse : bool, optional</span>
<span class="sd">        If sparse, eigenvalues will be calculated with arpack.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    n_eigen : int, optional</span>
<span class="sd">        Number of eigenvalues calculated by arpack.</span>
<span class="sd">        Default is 12.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A rotor object.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    evalues : array</span>
<span class="sd">        Rotor&#39;s eigenvalues.</span>
<span class="sd">    evectors : array</span>
<span class="sd">        Rotor&#39;s eigenvectors.</span>
<span class="sd">    wn : array</span>
<span class="sd">        Rotor&#39;s natural frequencies in rad/s.</span>
<span class="sd">    wd : array</span>
<span class="sd">        Rotor&#39;s damped natural frequencies in rad/s.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; #  Rotor without damping with 2 shaft elements 1 disk and 2 bearings</span>
<span class="sd">    &gt;&gt;&gt; from ross.materials import steel</span>
<span class="sd">    &gt;&gt;&gt; z = 0</span>
<span class="sd">    &gt;&gt;&gt; le = 0.25</span>
<span class="sd">    &gt;&gt;&gt; i_d = 0</span>
<span class="sd">    &gt;&gt;&gt; o_d = 0.05</span>
<span class="sd">    &gt;&gt;&gt; tim0 = ShaftElement(le, i_d, o_d, steel,</span>
<span class="sd">    ...                    shear_effects=True,</span>
<span class="sd">    ...                    rotary_inertia=True,</span>
<span class="sd">    ...                    gyroscopic=True)</span>
<span class="sd">    &gt;&gt;&gt; tim1 = ShaftElement(le, i_d, o_d, steel,</span>
<span class="sd">    ...                    shear_effects=True,</span>
<span class="sd">    ...                    rotary_inertia=True,</span>
<span class="sd">    ...                    gyroscopic=True)</span>
<span class="sd">    &gt;&gt;&gt; shaft_elm = [tim0, tim1]</span>
<span class="sd">    &gt;&gt;&gt; disk0 = DiskElement(1, steel, 0.07, 0.05, 0.28)</span>
<span class="sd">    &gt;&gt;&gt; stf = 1e6</span>
<span class="sd">    &gt;&gt;&gt; bearing0 = BearingElement(0, kxx=stf, cxx=0)</span>
<span class="sd">    &gt;&gt;&gt; bearing1 = BearingElement(2, kxx=stf, cxx=0)</span>
<span class="sd">    &gt;&gt;&gt; rotor = Rotor(shaft_elm, [disk0], [bearing0, bearing1])</span>
<span class="sd">    &gt;&gt;&gt; rotor.wd[0] # doctest: +ELLIPSIS</span>
<span class="sd">    215.3707...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shaft_elements</span><span class="p">,</span>
        <span class="n">disk_elements</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bearing_seal_elements</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">w</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">n_eigen</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
        <span class="n">min_w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rated_w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">w</span>

        <span class="c1">####################################################</span>
        <span class="c1"># Config attributes</span>
        <span class="c1">####################################################</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="n">sparse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_eigen</span> <span class="o">=</span> <span class="n">n_eigen</span>
        <span class="c1"># operational speeds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_w</span> <span class="o">=</span> <span class="n">min_w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_w</span> <span class="o">=</span> <span class="n">max_w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rated_w</span> <span class="o">=</span> <span class="n">rated_w</span>

        <span class="c1">####################################################</span>

        <span class="c1"># flatten shaft_elements</span>
        <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
                    <span class="k">yield from</span> <span class="n">flatten</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">el</span>

        <span class="c1"># flatten and make a copy for shaft elements to avoid altering</span>
        <span class="c1"># attributes for elements that might be used in different rotors</span>
        <span class="c1"># e.g. altering shaft_element.n</span>
        <span class="n">shaft_elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="n">shaft_elements</span><span class="p">)]</span>

        <span class="c1"># set n for each shaft element</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shaft_elements</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sh</span><span class="o">.</span><span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sh</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">if</span> <span class="n">disk_elements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">disk_elements</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">bearing_seal_elements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bearing_seal_elements</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shaft_elements</span> <span class="o">=</span> <span class="n">shaft_elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bearing_seal_elements</span> <span class="o">=</span> <span class="n">bearing_seal_elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disk_elements</span> <span class="o">=</span> <span class="n">disk_elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">el</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">shaft_elements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">disk_elements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bearing_seal_elements</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">]</span>

        <span class="c1">####################################################</span>
        <span class="c1"># Rotor summary</span>
        <span class="c1">####################################################</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;type&quot;</span><span class="p">,</span>
            <span class="s2">&quot;n&quot;</span><span class="p">,</span>
            <span class="s2">&quot;L&quot;</span><span class="p">,</span>
            <span class="s2">&quot;node_pos&quot;</span><span class="p">,</span>
            <span class="s2">&quot;node_pos_r&quot;</span><span class="p">,</span>
            <span class="s2">&quot;i_d&quot;</span><span class="p">,</span>
            <span class="s2">&quot;o_d&quot;</span><span class="p">,</span>
            <span class="s2">&quot;i_d_r&quot;</span><span class="p">,</span>
            <span class="s2">&quot;o_d_r&quot;</span><span class="p">,</span>
            <span class="s2">&quot;material&quot;</span><span class="p">,</span>
            <span class="s2">&quot;rho&quot;</span><span class="p">,</span>
            <span class="s2">&quot;volume&quot;</span><span class="p">,</span>
            <span class="s2">&quot;m&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="n">df_shaft</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">el</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shaft_elements</span><span class="p">])</span>
        <span class="n">df_disks</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">el</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">disk_elements</span><span class="p">])</span>
        <span class="n">df_bearings</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">el</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bearing_seal_elements</span><span class="p">])</span>

        <span class="n">nodes_pos_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_shaft</span><span class="o">.</span><span class="n">n_l</span><span class="p">))</span>
        <span class="n">nodes_pos_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_shaft</span><span class="o">.</span><span class="n">n_l</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_shaft</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nodes_pos_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_pos_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">df_shaft</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">df_shaft</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;n_l&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">df_shaft</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;n_l&quot;</span><span class="p">]:</span>
                <span class="n">nodes_pos_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_pos_l</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">nodes_pos_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_pos_r</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodes_pos_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_pos_r</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">nodes_pos_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_pos_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">df_shaft</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span><span class="p">]</span>

        <span class="n">df_shaft</span><span class="p">[</span><span class="s2">&quot;nodes_pos_l&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_pos_l</span>
        <span class="n">df_shaft</span><span class="p">[</span><span class="s2">&quot;nodes_pos_r&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_pos_r</span>
        <span class="c1"># bearings</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df_shaft</span><span class="p">,</span> <span class="n">df_disks</span><span class="p">,</span> <span class="n">df_bearings</span><span class="p">])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;n_l&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># check consistence for disks and bearings location</span>
        <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">n_l</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;ShaftElement&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">n_r</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trying to set disk or bearing outside shaft&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span>

        <span class="c1"># nodes axial position and diameter</span>
        <span class="n">nodes_pos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df_shaft</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;n_l&quot;</span><span class="p">)[</span><span class="s2">&quot;nodes_pos_l&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">nodes_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_shaft</span><span class="p">[</span><span class="s2">&quot;nodes_pos_r&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_pos</span> <span class="o">=</span> <span class="n">nodes_pos</span>

        <span class="n">nodes_i_d</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df_shaft</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;n_l&quot;</span><span class="p">)[</span><span class="s2">&quot;i_d&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">nodes_i_d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_shaft</span><span class="p">[</span><span class="s2">&quot;i_d&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_i_d</span> <span class="o">=</span> <span class="n">nodes_i_d</span>

        <span class="n">nodes_o_d</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df_shaft</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;n_l&quot;</span><span class="p">)[</span><span class="s2">&quot;o_d&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">nodes_o_d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_shaft</span><span class="p">[</span><span class="s2">&quot;o_d&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_o_d</span> <span class="o">=</span> <span class="n">nodes_o_d</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_pos</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;n_l&quot;</span><span class="p">)[</span><span class="s2">&quot;L&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">nodes_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># rotor mass can also be calculated with self.M()[::4, ::4].sum()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_disks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">disk</span><span class="o">.</span><span class="n">m</span> <span class="k">for</span> <span class="n">disk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">disk_elements</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_shaft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">sh_el</span><span class="o">.</span><span class="n">m</span> <span class="k">for</span> <span class="n">sh_el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shaft_elements</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_disks</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_shaft</span>

        <span class="c1"># values for evalues and evectors will be calculated by self._calc_system</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evalues</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evectors</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wn</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wd</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lti</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_v0</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># used to call eigs</span>

        <span class="c1"># number of dofs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="nb">max</span><span class="p">([</span><span class="n">el</span><span class="o">.</span><span class="n">n</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">shaft_elements</span><span class="p">])</span> <span class="o">+</span> <span class="mi">8</span>

        <span class="c1">#  diameter at node position</span>

        <span class="c1"># call self._calc_system() to calculate current evalues and evectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_system</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_calc_system</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evalues</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">evectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>
        <span class="n">wn_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalues</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wn</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalues</span><span class="p">))[:</span><span class="n">wn_len</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wd</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalues</span><span class="p">))[:</span><span class="n">wn_len</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">damping_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalues</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalues</span><span class="p">))[</span>
            <span class="p">:</span><span class="n">wn_len</span>
        <span class="p">]</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_dec</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">damping_ratio</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">damping_ratio</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lti</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lti</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">w</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w</span>

    <span class="nd">@w</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_system</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_dofs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;The first and last dof for a given element&quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">n</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">node</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">ShaftElement</span><span class="p">):</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="mi">8</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">DiskElement</span><span class="p">):</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="mi">4</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">BearingElement</span><span class="p">):</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span>

<div class="viewcode-block" id="Rotor.M"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.M">[docs]</a>    <span class="k">def</span> <span class="nf">M</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Mass matrix for an instance of a rotor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Mass matrix for the rotor.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rotor = rotor_example()</span>
<span class="sd">        &gt;&gt;&gt; rotor.M()[:4, :4]</span>
<span class="sd">        array([[ 1.42050794,  0.        ,  0.        ,  0.04931719],</span>
<span class="sd">               [ 0.        ,  1.42050794, -0.04931719,  0.        ],</span>
<span class="sd">               [ 0.        , -0.04931719,  0.00231392,  0.        ],</span>
<span class="sd">               [ 0.04931719,  0.        ,  0.        ,  0.00231392]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Create the matrices</span>
        <span class="n">M0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">elm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shaft_elements</span><span class="p">:</span>
            <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dofs</span><span class="p">(</span><span class="n">elm</span><span class="p">)</span>
            <span class="n">M0</span><span class="p">[</span><span class="n">n1</span><span class="p">:</span><span class="n">n2</span><span class="p">,</span> <span class="n">n1</span><span class="p">:</span><span class="n">n2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">elm</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">elm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">disk_elements</span><span class="p">:</span>
            <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dofs</span><span class="p">(</span><span class="n">elm</span><span class="p">)</span>
            <span class="n">M0</span><span class="p">[</span><span class="n">n1</span><span class="p">:</span><span class="n">n2</span><span class="p">,</span> <span class="n">n1</span><span class="p">:</span><span class="n">n2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">elm</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">M0</span></div>

<div class="viewcode-block" id="Rotor.K"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.K">[docs]</a>    <span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stiffness matrix for an instance of a rotor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Stiffness matrix for the rotor.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rotor = rotor_example()</span>
<span class="sd">        &gt;&gt;&gt; np.round(rotor.K()[:4, :4]/1e6)</span>
<span class="sd">        array([[ 47.,   0.,   0.,   6.],</span>
<span class="sd">               [  0.,  46.,  -6.,   0.],</span>
<span class="sd">               [  0.,  -6.,   1.,   0.],</span>
<span class="sd">               [  6.,   0.,   0.,   1.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span>
        <span class="c1">#  Create the matrices</span>
        <span class="n">K0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">elm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shaft_elements</span><span class="p">:</span>
            <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dofs</span><span class="p">(</span><span class="n">elm</span><span class="p">)</span>
            <span class="n">K0</span><span class="p">[</span><span class="n">n1</span><span class="p">:</span><span class="n">n2</span><span class="p">,</span> <span class="n">n1</span><span class="p">:</span><span class="n">n2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">elm</span><span class="o">.</span><span class="n">K</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">elm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bearing_seal_elements</span><span class="p">:</span>
            <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dofs</span><span class="p">(</span><span class="n">elm</span><span class="p">)</span>
            <span class="n">K0</span><span class="p">[</span><span class="n">n1</span><span class="p">:</span><span class="n">n2</span><span class="p">,</span> <span class="n">n1</span><span class="p">:</span><span class="n">n2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">elm</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="c1">#  Skew-symmetric speed dependent contribution to element stiffness matrix</span>
        <span class="c1">#  from the internal damping.</span>

        <span class="k">return</span> <span class="n">K0</span></div>

<div class="viewcode-block" id="Rotor.C"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.C">[docs]</a>    <span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Damping matrix for an instance of a rotor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Damping matrix for the rotor.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rotor = rotor_example()</span>
<span class="sd">        &gt;&gt;&gt; rotor.C()[:4, :4]</span>
<span class="sd">        array([[ 0.,  0.,  0.,  0.],</span>
<span class="sd">               [ 0.,  0.,  0.,  0.],</span>
<span class="sd">               [ 0.,  0.,  0.,  0.],</span>
<span class="sd">               [ 0.,  0.,  0.,  0.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span>
        <span class="c1">#  Create the matrices</span>
        <span class="n">C0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">elm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bearing_seal_elements</span><span class="p">:</span>
            <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dofs</span><span class="p">(</span><span class="n">elm</span><span class="p">)</span>
            <span class="n">C0</span><span class="p">[</span><span class="n">n1</span><span class="p">:</span><span class="n">n2</span><span class="p">,</span> <span class="n">n1</span><span class="p">:</span><span class="n">n2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">elm</span><span class="o">.</span><span class="n">C</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">C0</span></div>

<div class="viewcode-block" id="Rotor.G"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.G">[docs]</a>    <span class="k">def</span> <span class="nf">G</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gyroscopic matrix for an instance of a rotor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Gyroscopic matrix for the rotor.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rotor = rotor_example()</span>
<span class="sd">        &gt;&gt;&gt; rotor.G()[:4, :4]</span>
<span class="sd">        array([[ 0.        ,  0.01943344, -0.00022681,  0.        ],</span>
<span class="sd">               [-0.01943344,  0.        ,  0.        , -0.00022681],</span>
<span class="sd">               [ 0.00022681,  0.        ,  0.        ,  0.0001524 ],</span>
<span class="sd">               [ 0.        ,  0.00022681, -0.0001524 ,  0.        ]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Create the matrices</span>
        <span class="n">G0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">elm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shaft_elements</span><span class="p">:</span>
            <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dofs</span><span class="p">(</span><span class="n">elm</span><span class="p">)</span>
            <span class="n">G0</span><span class="p">[</span><span class="n">n1</span><span class="p">:</span><span class="n">n2</span><span class="p">,</span> <span class="n">n1</span><span class="p">:</span><span class="n">n2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">elm</span><span class="o">.</span><span class="n">G</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">elm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">disk_elements</span><span class="p">:</span>
            <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dofs</span><span class="p">(</span><span class="n">elm</span><span class="p">)</span>
            <span class="n">G0</span><span class="p">[</span><span class="n">n1</span><span class="p">:</span><span class="n">n2</span><span class="p">,</span> <span class="n">n1</span><span class="p">:</span><span class="n">n2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">elm</span><span class="o">.</span><span class="n">G</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">G0</span></div>

<div class="viewcode-block" id="Rotor.A"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.A">[docs]</a>    <span class="k">def</span> <span class="nf">A</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;State space matrix for an instance of a rotor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        State space matrix for the rotor.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rotor = rotor_example()</span>
<span class="sd">        &gt;&gt;&gt; np.round(rotor.A()[50:56, :2])</span>
<span class="sd">        array([[     0.,  11110.],</span>
<span class="sd">               [-11106.,     -0.],</span>
<span class="sd">               [  -169.,     -0.],</span>
<span class="sd">               [    -0.,   -169.],</span>
<span class="sd">               [    -0.,  10511.],</span>
<span class="sd">               [-10507.,     -0.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">))</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span>

        <span class="c1"># fmt: off</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Z</span><span class="p">,</span> <span class="n">I</span><span class="p">]),</span>
             <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">w</span><span class="p">)),</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">(),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">()</span><span class="o">*</span><span class="n">w</span><span class="p">))])])</span>
        <span class="c1"># fmt: on</span>

        <span class="k">return</span> <span class="n">A</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_index</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Function used to generate an index that will sort</span>
<span class="sd">        eigenvalues and eigenvectors based on the imaginary (wd)</span>
<span class="sd">        part of the eigenvalues. Positive eigenvalues will be</span>
<span class="sd">        positioned at the first half of the array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        eigenvalues: array</span>
<span class="sd">            Array with the eigenvalues.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idx:</span>
<span class="sd">            An array with indices that will sort the</span>
<span class="sd">            eigenvalues and eigenvectors.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rotor = rotor_example()</span>
<span class="sd">        &gt;&gt;&gt; evalues, evectors = rotor._eigen(0, sorted_=False)</span>
<span class="sd">        &gt;&gt;&gt; idx = rotor._index(evalues)</span>
<span class="sd">        &gt;&gt;&gt; idx[:6] # doctest: +ELLIPSIS</span>
<span class="sd">        array([ 1,  3,  5,  7,  9, 11]...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># avoid float point errors when sorting</span>
        <span class="n">evals_truncated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">evals_truncated</span><span class="p">)</span>  <span class="c1"># First column</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">evals_truncated</span><span class="p">)</span>  <span class="c1"># Second column</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>  <span class="c1"># Sort by imag, then by absolute</span>
        <span class="c1"># Positive eigenvalues first</span>
        <span class="n">positive</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="p">:]]</span>
        <span class="n">negative</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]]</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">positive</span><span class="p">,</span> <span class="n">negative</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">idx</span>

    <span class="k">def</span> <span class="nf">_eigen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sorted_</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;This method will return the eigenvalues and eigenvectors of the</span>
<span class="sd">        state space matrix A, sorted by the index method which considers</span>
<span class="sd">        the imaginary part (wd) of the eigenvalues for sorting.</span>
<span class="sd">        To avoid sorting use sorted_=False</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        w: float</span>
<span class="sd">            Rotor speed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        evalues: array</span>
<span class="sd">            An array with the eigenvalues</span>
<span class="sd">        evectors array</span>
<span class="sd">            An array with the eigenvectors</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rotor = rotor_example()</span>
<span class="sd">        &gt;&gt;&gt; evalues, evectors = rotor._eigen(0)</span>
<span class="sd">        &gt;&gt;&gt; evalues[0].imag # doctest: +ELLIPSIS</span>
<span class="sd">        82.653...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span>
        <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">evalues</span><span class="p">,</span> <span class="n">evectors</span> <span class="o">=</span> <span class="n">las</span><span class="o">.</span><span class="n">eigs</span><span class="p">(</span>
                    <span class="n">A</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eigen</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ncv</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;LM&quot;</span><span class="p">,</span> <span class="n">v0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_v0</span>
                <span class="p">)</span>
                <span class="c1"># store v0 as a linear combination of the previously</span>
                <span class="c1"># calculated eigenvectors to use in the next call to eigs</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">evectors</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">las</span><span class="o">.</span><span class="n">ArpackError</span><span class="p">:</span>
                <span class="n">evalues</span><span class="p">,</span> <span class="n">evectors</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">evalues</span><span class="p">,</span> <span class="n">evectors</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sorted_</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">evalues</span><span class="p">,</span> <span class="n">evectors</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">(</span><span class="n">evalues</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">evalues</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">evectors</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span>

<div class="viewcode-block" id="Rotor.H_kappa"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.H_kappa">[docs]</a>    <span class="k">def</span> <span class="nf">H_kappa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">return_T</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the H matrix for a given node and natural frequency.</span>

<span class="sd">        The matrix H contains information about the whirl direction,</span>
<span class="sd">        the orbit minor and major axis and the orbit inclination.</span>
<span class="sd">        The matrix is calculated by :math:`H = T.T^T` where the</span>
<span class="sd">        matrix T is constructed using the eigenvector corresponding</span>
<span class="sd">        to the natural frequency of interest:</span>

<span class="sd">        .. math::</span>
<span class="sd">           :nowrap:</span>

<span class="sd">           \begin{eqnarray}</span>
<span class="sd">              \begin{bmatrix}</span>
<span class="sd">              u(t)\\</span>
<span class="sd">              v(t)</span>
<span class="sd">              \end{bmatrix}</span>
<span class="sd">              = \mathfrak{R}\Bigg(</span>
<span class="sd">              \begin{bmatrix}</span>
<span class="sd">              r_u e^{j\eta_u}\\</span>
<span class="sd">              r_v e^{j\eta_v}</span>
<span class="sd">              \end{bmatrix}\Bigg)</span>
<span class="sd">              e^{j\omega_i t}</span>
<span class="sd">              =</span>
<span class="sd">              \begin{bmatrix}</span>
<span class="sd">              r_u cos(\eta_u + \omega_i t)\\</span>
<span class="sd">              r_v cos(\eta_v + \omega_i t)</span>
<span class="sd">              \end{bmatrix}</span>
<span class="sd">              = {\bf T}</span>
<span class="sd">              \begin{bmatrix}</span>
<span class="sd">              cos(\omega_i t)\\</span>
<span class="sd">              sin(\omega_i t)</span>
<span class="sd">              \end{bmatrix}</span>
<span class="sd">           \end{eqnarray}</span>

<span class="sd">        Where :math:`r_u e^{j\eta_u}` e :math:`r_v e^{j\eta_v}` are the</span>
<span class="sd">        elements of the *i*\th eigenvector, corresponding to the node and</span>
<span class="sd">        natural frequency of interest (mode).</span>

<span class="sd">        .. math::</span>

<span class="sd">            {\bf T} =</span>
<span class="sd">            \begin{bmatrix}</span>
<span class="sd">            r_u cos(\eta_u) &amp; -r_u sin(\eta_u)\\</span>
<span class="sd">            r_u cos(\eta_u) &amp; -r_v sin(\eta_v)</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: int</span>
<span class="sd">            Node for which the matrix H will be calculated.</span>
<span class="sd">        w: int</span>
<span class="sd">            Index corresponding to the natural frequency</span>
<span class="sd">            of interest.</span>
<span class="sd">        return_T: bool, optional</span>
<span class="sd">            If True, returns the H matrix and a dictionary with the</span>
<span class="sd">            values for :math:`r_u, r_v, \eta_u, \eta_v`.</span>

<span class="sd">            Default is false.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        H: array</span>
<span class="sd">            Matrix H.</span>
<span class="sd">        Tdic: dict</span>
<span class="sd">            Dictionary with values for :math:`r_u, r_v, \eta_u, \eta_v`.</span>

<span class="sd">            It will be returned only if return_T is True.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rotor = rotor_example()</span>
<span class="sd">        &gt;&gt;&gt; # H matrix for the 0th node</span>
<span class="sd">        &gt;&gt;&gt; rotor.H_kappa(0, 0) # doctest: +ELLIPSIS</span>
<span class="sd">        array([[  8.78547006e-30,  -4.30647963e-18],</span>
<span class="sd">               [ -4.30647963e-18,   2.11429917e-06]])</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get vector of interest based on freqs</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evectors</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">node</span> <span class="p">:</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">node</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span>
        <span class="c1"># get translation sdofs for specified node for each mode</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ru</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="n">nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">nv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="c1"># fmt: off</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">ru</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">nu</span><span class="p">),</span> <span class="o">-</span><span class="n">ru</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">nu</span><span class="p">)],</span>
                      <span class="p">[</span><span class="n">rv</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">nv</span><span class="p">),</span> <span class="o">-</span><span class="n">rv</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">nv</span><span class="p">)]])</span>
        <span class="c1"># fmt: on</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">T</span> <span class="o">@</span> <span class="n">T</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">return_T</span><span class="p">:</span>
            <span class="n">Tdic</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ru&quot;</span><span class="p">:</span> <span class="n">ru</span><span class="p">,</span> <span class="s2">&quot;rv&quot;</span><span class="p">:</span> <span class="n">rv</span><span class="p">,</span> <span class="s2">&quot;nu&quot;</span><span class="p">:</span> <span class="n">nu</span><span class="p">,</span> <span class="s2">&quot;nv&quot;</span><span class="p">:</span> <span class="n">nv</span><span class="p">}</span>
            <span class="k">return</span> <span class="n">H</span><span class="p">,</span> <span class="n">Tdic</span>

        <span class="k">return</span> <span class="n">H</span></div>

<div class="viewcode-block" id="Rotor.kappa"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.kappa">[docs]</a>    <span class="k">def</span> <span class="nf">kappa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">wd</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates kappa for a given node and natural frequency.</span>

<span class="sd">        w is the the index of the natural frequency of interest.</span>
<span class="sd">        The function calculates the orbit parameter :math:`\kappa`:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \kappa = \pm \sqrt{\lambda_2 / \lambda_1}</span>

<span class="sd">        Where :math:`\sqrt{\lambda_1}` is the length of the semiminor axes</span>
<span class="sd">        and :math:`\sqrt{\lambda_2}` is the length of the semimajor axes.</span>

<span class="sd">        If :math:`\kappa = \pm 1`, the orbit is circular.</span>

<span class="sd">        If :math:`\kappa` is positive we have a forward rotating orbit</span>
<span class="sd">        and if it is negative we have a backward rotating orbit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: int</span>
<span class="sd">            Node for which kappa will be calculated.</span>
<span class="sd">        w: int</span>
<span class="sd">            Index corresponding to the natural frequency</span>
<span class="sd">            of interest.</span>
<span class="sd">        wd: bool</span>
<span class="sd">            If True, damping natural frequencies are used.</span>

<span class="sd">            Default is true.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        kappa: dict</span>
<span class="sd">            A dictionary with values for the natural frequency,</span>
<span class="sd">            major axis, minor axis and kappa.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rotor = rotor_example()</span>
<span class="sd">        &gt;&gt;&gt; # kappa for each node of the first natural frequency</span>
<span class="sd">        &gt;&gt;&gt; # Major axes for node 0 and natural frequency (mode) 0.</span>
<span class="sd">        &gt;&gt;&gt; rotor.kappa(0, 0)[&#39;Major axes&#39;] # doctest: +ELLIPSIS</span>
<span class="sd">        0.00145...</span>
<span class="sd">        &gt;&gt;&gt; # kappa for node 2 and natural frequency (mode) 3.</span>
<span class="sd">        &gt;&gt;&gt; rotor.kappa(2, 3)[&#39;kappa&#39;] # doctest: +ELLIPSIS</span>
<span class="sd">        8.539...e-14</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">wd</span><span class="p">:</span>
            <span class="n">nat_freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wd</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nat_freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wn</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>

        <span class="n">H</span><span class="p">,</span> <span class="n">Tvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_kappa</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">return_T</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">Tvals</span><span class="p">[</span><span class="s2">&quot;nu&quot;</span><span class="p">]</span>
        <span class="n">nv</span> <span class="o">=</span> <span class="n">Tvals</span><span class="p">[</span><span class="s2">&quot;nv&quot;</span><span class="p">]</span>

        <span class="n">lam</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">H</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># lam is the eigenvalue -&gt; sqrt(lam) is the minor/major axis.</span>
        <span class="c1"># kappa encodes the relation between the axis and the precession.</span>
        <span class="n">minor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lam</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">major</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lam</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">kappa</span> <span class="o">=</span> <span class="n">minor</span> <span class="o">/</span> <span class="n">major</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">nv</span> <span class="o">-</span> <span class="n">nu</span>

        <span class="c1"># we need to evaluate if 0 &lt; nv - nu &lt; pi.</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">elif</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="c1"># if nv = nu or nv = nu + pi then the response is a straight line.</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">diff</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
            <span class="n">kappa</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># if 0 &lt; nv - nu &lt; pi, then a backward rotating mode exists.</span>
        <span class="k">elif</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
            <span class="n">kappa</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">k</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Frequency&quot;</span><span class="p">:</span> <span class="n">nat_freq</span><span class="p">,</span>
            <span class="s2">&quot;Minor axes&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">minor</span><span class="p">),</span>
            <span class="s2">&quot;Major axes&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">major</span><span class="p">),</span>
            <span class="s2">&quot;kappa&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">kappa</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">k</span></div>

<div class="viewcode-block" id="Rotor.kappa_mode"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.kappa_mode">[docs]</a>    <span class="k">def</span> <span class="nf">kappa_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;This function evaluates kappa given the index of</span>
<span class="sd">        the natural frequency of interest.</span>
<span class="sd">        Values of kappa are evaluated for each node of the</span>
<span class="sd">        corresponding frequency mode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        w: int</span>
<span class="sd">            Index corresponding to the natural frequency</span>
<span class="sd">            of interest.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        kappa_mode: list</span>
<span class="sd">            A list with the value of kappa for each node related</span>
<span class="sd">            to the mode/natural frequency of interest.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rotor = rotor_example()</span>
<span class="sd">        &gt;&gt;&gt; # kappa for each node of the first natural frequency</span>
<span class="sd">        &gt;&gt;&gt; rotor.kappa_mode(0) # doctest: +ELLIPSIS</span>
<span class="sd">        [-0.0, -0.0, -0.0, -0.0, -1.153...e-08, -0.0, -1.239...e-08]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kappa_mode</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">w</span><span class="p">)[</span><span class="s2">&quot;kappa&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">kappa_mode</span></div>

<div class="viewcode-block" id="Rotor.whirl_direction"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.whirl_direction">[docs]</a>    <span class="k">def</span> <span class="nf">whirl_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the whirl direction for each frequency.&quot;&quot;&quot;</span>
        <span class="c1"># whirl direction/values are methods because they are expensive.</span>
        <span class="n">whirl_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">whirl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kappa_mode</span><span class="p">(</span><span class="n">wd</span><span class="p">))</span> <span class="k">for</span> <span class="n">wd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wd</span><span class="p">))]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">whirl_w</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rotor.whirl_values"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.whirl_values">[docs]</a>    <span class="k">def</span> <span class="nf">whirl_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the whirl value (0., 0.5, or 1.) for each frequency.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">whirl_to_cmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">whirl_direction</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">orbit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_lti</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Continuous-time linear time invariant system.</span>

<span class="sd">        This method is used to create a Continuous-time linear</span>
<span class="sd">        time invariant system for the mdof system.</span>
<span class="sd">        From this system we can obtain poles, impulse response,</span>
<span class="sd">        generate a bode, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">))</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span>

        <span class="c1"># x&#39; = Ax + Bu</span>
        <span class="n">B2</span> <span class="o">=</span> <span class="n">I</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">()</span>
        <span class="c1"># fmt: off</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">Z</span><span class="p">,</span>
                       <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">(),</span> <span class="n">B2</span><span class="p">)])</span>
        <span class="c1"># fmt: on</span>

        <span class="c1"># y = Cx + Du</span>
        <span class="c1"># Observation matrices</span>
        <span class="n">Cd</span> <span class="o">=</span> <span class="n">I</span>
        <span class="n">Cv</span> <span class="o">=</span> <span class="n">Z</span>
        <span class="n">Ca</span> <span class="o">=</span> <span class="n">Z</span>

        <span class="c1"># fmt: off</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Cd</span> <span class="o">-</span> <span class="n">Ca</span> <span class="o">@</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">()),</span> <span class="n">Cv</span> <span class="o">-</span> <span class="n">Ca</span> <span class="o">@</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">())))</span>
        <span class="c1"># fmt: on</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">Ca</span> <span class="o">@</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">(),</span> <span class="n">B2</span><span class="p">)</span>

        <span class="n">sys</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">lti</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sys</span>

    <span class="k">def</span> <span class="nf">transfer_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">modes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lti</span><span class="o">.</span><span class="n">B</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lti</span><span class="o">.</span><span class="n">C</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lti</span><span class="o">.</span><span class="n">D</span>

        <span class="c1"># calculate eigenvalues and eigenvectors using la.eig to get</span>
        <span class="c1"># left and right eigenvectors.</span>

        <span class="n">evals</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>

        <span class="n">psi_inv</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">modes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span>  <span class="c1"># n dof -&gt; number of modes</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">modes</span><span class="p">)</span>  <span class="c1"># -&gt; number of desired modes</span>
            <span class="c1"># idx to get each evalue/evector and its conjugate</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">m</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
            <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">modes</span>  <span class="c1"># modes</span>
            <span class="n">idx</span><span class="p">[</span><span class="n">m</span><span class="p">:]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)[</span><span class="o">-</span><span class="n">m</span><span class="p">:]</span>  <span class="c1"># conjugates (see how evalues are ordered)</span>

            <span class="n">evals</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span>
            <span class="n">psi</span> <span class="o">=</span> <span class="n">psi</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">),</span> <span class="n">idx</span><span class="p">)]</span>
            <span class="n">psi_inv</span> <span class="o">=</span> <span class="n">psi_inv</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">))]</span>

        <span class="n">diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">-</span> <span class="n">lam</span><span class="p">)</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">evals</span><span class="p">])</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">C</span> <span class="o">@</span> <span class="n">psi</span> <span class="o">@</span> <span class="n">diag</span> <span class="o">@</span> <span class="n">psi_inv</span> <span class="o">@</span> <span class="n">B</span> <span class="o">+</span> <span class="n">D</span>

        <span class="k">return</span> <span class="n">H</span>

<div class="viewcode-block" id="Rotor.freq_response"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.freq_response">[docs]</a>    <span class="k">def</span> <span class="nf">freq_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">modes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Frequency response for a mdof system.</span>

<span class="sd">        This method returns the frequency response for a mdof system</span>
<span class="sd">        given a range of frequencies and the modes that will be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        force : array, optional</span>
<span class="sd">            Force array (needs to have the same length as frequencies array).</span>
<span class="sd">            If not given the impulse response is calculated.</span>
<span class="sd">        omega : array, optional</span>
<span class="sd">            Array with the desired range of frequencies (the default</span>
<span class="sd">             is 0 to 1.5 x highest damped natural frequency.</span>
<span class="sd">        modes : list, optional</span>
<span class="sd">            Modes that will be used to calculate the frequency response</span>
<span class="sd">            (all modes will be used if a list is not given).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        omega : array</span>
<span class="sd">            Array with the frequencies</span>
<span class="sd">        magdb : array</span>
<span class="sd">            Magnitude (dB) of the frequency response for each pair input/output.</span>
<span class="sd">            The order of the array is: [output, input, magnitude]</span>
<span class="sd">        phase : array</span>
<span class="sd">            Phase of the frequency response for each pair input/output.</span>
<span class="sd">            The order of the array is: [output, input, phase]</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">frequency_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">frequency_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalues</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

        <span class="n">freq_resp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lti</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lti</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">frequency_range</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frequency_range</span><span class="p">):</span>
            <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transfer_matrix</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">modes</span><span class="o">=</span><span class="n">modes</span><span class="p">)</span>
            <span class="n">freq_resp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">FrequencyResponseResults</span><span class="p">(</span>
            <span class="n">freq_resp</span><span class="p">,</span>
            <span class="n">new_attributes</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;frequency_range&quot;</span><span class="p">:</span> <span class="n">frequency_range</span><span class="p">,</span>
                <span class="s2">&quot;magnitude&quot;</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">freq_resp</span><span class="p">),</span>
                <span class="s2">&quot;phase&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">freq_resp</span><span class="p">),</span>
            <span class="p">},</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>

    <span class="k">def</span> <span class="nf">forced_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frequency_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">modes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">freq_resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_response</span><span class="p">(</span><span class="n">frequency_range</span><span class="o">=</span><span class="n">frequency_range</span><span class="p">,</span> <span class="n">modes</span><span class="o">=</span><span class="n">modes</span><span class="p">)</span>

        <span class="n">forced_resp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq_resp</span><span class="o">.</span><span class="n">frequency_range</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freq_resp</span><span class="o">.</span><span class="n">frequency_range</span><span class="p">)):</span>
            <span class="n">forced_resp</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_resp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">force</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

        <span class="n">forced_resp</span> <span class="o">=</span> <span class="n">ForcedResponseResults</span><span class="p">(</span>
            <span class="n">forced_resp</span><span class="p">,</span>
            <span class="n">new_attributes</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;frequency_range&quot;</span><span class="p">:</span> <span class="n">frequency_range</span><span class="p">,</span>
                <span class="s2">&quot;magnitude&quot;</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">forced_resp</span><span class="p">),</span>
                <span class="s2">&quot;phase&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">forced_resp</span><span class="p">),</span>
            <span class="p">},</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">forced_resp</span>

    <span class="k">def</span> <span class="nf">_unbalance_force</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function to calculate unbalance force&quot;&quot;&quot;</span>

        <span class="n">F0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">omega</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">me</span> <span class="o">=</span> <span class="n">magnitude</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">phase</span>
        <span class="n">b0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">me</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">delta</span><span class="p">),</span>
                <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">me</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">delta</span><span class="p">),</span>
                <span class="mi">0</span><span class="p">,</span>  <span class="c1"># 1j*(Id - Ip)*beta*np.exp(1j*gamma),</span>
                <span class="mi">0</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># (Id - Ip)*beta*np.exp(1j*gamma)])</span>

        <span class="n">n0</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">node</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n0</span> <span class="o">+</span> <span class="mi">4</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">omega</span><span class="p">):</span>
            <span class="n">F0</span><span class="p">[</span><span class="n">n0</span><span class="p">:</span><span class="n">n1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">w</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">b0</span>

        <span class="k">return</span> <span class="n">F0</span>

<div class="viewcode-block" id="Rotor.unbalance_response"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.unbalance_response">[docs]</a>    <span class="k">def</span> <span class="nf">unbalance_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">frequency_range</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;frequency response for a mdof system.</span>

<span class="sd">        This method returns the frequency response for a mdof system</span>
<span class="sd">        given a range of frequencies and the modes that will be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node : list, int</span>
<span class="sd">            Node where the unbalance is applied.</span>
<span class="sd">        magnitude : list, float</span>
<span class="sd">            Unbalance magnitude (kg.m)</span>
<span class="sd">        phase : list, float</span>
<span class="sd">            Unbalance phase (rad)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        frequency_range : array</span>
<span class="sd">            Array with the frequencies</span>
<span class="sd">        magdb : array</span>
<span class="sd">            Magnitude (dB) of the frequency response for each pair input/output.</span>
<span class="sd">            The order of the array is: [output, input, magnitude]</span>
<span class="sd">        phase : array</span>
<span class="sd">            Phase of the frequency response for each pair input/output.</span>
<span class="sd">            The order of the array is: [output, input, phase]</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">force</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">frequency_range</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
                <span class="n">force</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unbalance_force</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">frequency_range</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unbalance_force</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">frequency_range</span><span class="p">)</span>

        <span class="n">forced_response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forced_response</span><span class="p">(</span><span class="n">force</span><span class="p">,</span> <span class="n">frequency_range</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">forced_response</span></div>

<div class="viewcode-block" id="Rotor.time_response"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.time_response">[docs]</a>    <span class="k">def</span> <span class="nf">time_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">ic</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Time response for a rotor.</span>

<span class="sd">        This method returns the time response for a rotor</span>
<span class="sd">        given a force, time and initial conditions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        F : array</span>
<span class="sd">            Force array (needs to have the same length as time array).</span>
<span class="sd">        t : array</span>
<span class="sd">            Time array.</span>
<span class="sd">        ic : array, optional</span>
<span class="sd">            The initial conditions on the state vector (zero by default).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t : array</span>
<span class="sd">            Time values for the output.</span>
<span class="sd">        yout : array</span>
<span class="sd">            System response.</span>
<span class="sd">        xout : array</span>
<span class="sd">            Time evolution of the state vector.</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">signal</span><span class="o">.</span><span class="n">lsim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lti</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">X0</span><span class="o">=</span><span class="n">ic</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rotor.plot_rotor"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.plot_rotor">[docs]</a>    <span class="k">def</span> <span class="nf">plot_rotor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots a rotor object.</span>

<span class="sd">        This function will take a rotor object and plot its shaft,</span>
<span class="sd">        disks and bearing elements</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes : int, optional</span>
<span class="sd">            Increment that will be used to plot nodes label.</span>
<span class="sd">        ax : matplotlib axes, optional</span>
<span class="sd">            Axes in which the plot will be drawn.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : matplotlib axes</span>
<span class="sd">            Returns the axes object with the plot.</span>

<span class="sd">        Examples:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="c1">#  plot shaft centerline</span>
        <span class="n">shaft_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="o">-.</span><span class="mi">2</span> <span class="o">*</span> <span class="n">shaft_end</span><span class="p">,</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">shaft_end</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;k-.&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">max_diameter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">disk</span><span class="o">.</span><span class="n">o_d</span> <span class="k">for</span> <span class="n">disk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">disk_elements</span><span class="p">])</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="n">max_diameter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">shaft</span><span class="o">.</span><span class="n">o_d</span> <span class="k">for</span> <span class="n">shaft</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shaft_elements</span><span class="p">])</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">max_diameter</span><span class="p">,</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">max_diameter</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Axial location (m)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Shaft radius (m)&quot;</span><span class="p">)</span>

        <span class="c1">#  plot nodes</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">position</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_pos</span><span class="p">[::</span><span class="n">nodes</span><span class="p">]):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">position</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#6caed6&quot;</span><span class="p">,</span>
                <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
                <span class="n">position</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="n">f</span><span class="s2">&quot;{node*nodes}&quot;</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="s2">&quot;smaller&quot;</span><span class="p">,</span>
                <span class="n">horizontalalignment</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
                <span class="n">verticalalignment</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># plot shaft elements</span>
        <span class="k">for</span> <span class="n">sh_elm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shaft_elements</span><span class="p">:</span>
            <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_pos</span><span class="p">[</span><span class="n">sh_elm</span><span class="o">.</span><span class="n">n</span><span class="p">]</span>
            <span class="n">sh_elm</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>

        <span class="c1"># plot disk elements</span>
        <span class="k">for</span> <span class="n">disk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">disk_elements</span><span class="p">:</span>
            <span class="n">position</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_pos</span><span class="p">[</span><span class="n">disk</span><span class="o">.</span><span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_o_d</span><span class="p">[</span><span class="n">disk</span><span class="o">.</span><span class="n">n</span><span class="p">])</span>
            <span class="n">disk</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>

        <span class="c1"># plot bearings</span>
        <span class="k">for</span> <span class="n">bearing</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bearing_seal_elements</span><span class="p">:</span>
            <span class="n">position</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_pos</span><span class="p">[</span><span class="n">bearing</span><span class="o">.</span><span class="n">n</span><span class="p">],</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_o_d</span><span class="p">[</span><span class="n">bearing</span><span class="o">.</span><span class="n">n</span><span class="p">])</span>
            <span class="n">bearing</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Rotor.campbell"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.campbell">[docs]</a>    <span class="k">def</span> <span class="nf">campbell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">speed_range</span><span class="p">,</span> <span class="n">frequencies</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">frequency_type</span><span class="o">=</span><span class="s2">&quot;wd&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the Campbell diagram.</span>

<span class="sd">        This function will calculate the damped natural frequencies</span>
<span class="sd">        for a speed range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        speed_range : array</span>
<span class="sd">            Array with the speed range in rad/s.</span>
<span class="sd">        frequencies : int, optional</span>
<span class="sd">            Number of frequencies that will be calculated.</span>
<span class="sd">            Default is 6.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : array</span>
<span class="sd">            Array with the natural frequencies corresponding to each speed</span>
<span class="sd">            of the speed_rad array. It will be returned if plot=False.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rotor1 = rotor_example()</span>
<span class="sd">        &gt;&gt;&gt; speed = np.linspace(0, 400, 101)</span>
<span class="sd">        &gt;&gt;&gt; camp = rotor1.campbell(speed)</span>
<span class="sd">        &gt;&gt;&gt; np.round(camp[:, 0], 1) #  damped natural frequencies at the first rotor speed (0 rad/s)</span>
<span class="sd">        array([  82.7,   86.7,  254.5,  274.3,  679.5,  716.8])</span>
<span class="sd">        &gt;&gt;&gt; np.round(camp[:, 10], 1) # damped natural frequencies at 40 rad/s</span>
<span class="sd">        array([  82.6,   86.7,  254.3,  274.5,  676.5,  719.7])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rotor_current_speed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span>

        <span class="c1"># store in results [speeds(x axis), frequencies[0] or logdec[1] or</span>
        <span class="c1"># whirl[2](y axis), 3]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">speed_range</span><span class="p">),</span> <span class="n">frequencies</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">speed_range</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">w</span>

            <span class="k">if</span> <span class="n">frequency_type</span> <span class="o">==</span> <span class="s2">&quot;wd&quot;</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wd</span><span class="p">[:</span><span class="n">frequencies</span><span class="p">]</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_dec</span><span class="p">[:</span><span class="n">frequencies</span><span class="p">]</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whirl_values</span><span class="p">()[:</span><span class="n">frequencies</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wn</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wn</span><span class="p">[</span><span class="n">idx</span><span class="p">][:</span><span class="n">frequencies</span><span class="p">]</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_dec</span><span class="p">[</span><span class="n">idx</span><span class="p">][:</span><span class="n">frequencies</span><span class="p">]</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whirl_values</span><span class="p">()[</span><span class="n">idx</span><span class="p">][:</span><span class="n">frequencies</span><span class="p">]</span>

            <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>
            <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wn</span><span class="p">[:</span><span class="n">frequencies</span><span class="p">]</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">CampbellResults</span><span class="p">(</span>
            <span class="n">results</span><span class="p">,</span>
            <span class="n">new_attributes</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;speed_range&quot;</span><span class="p">:</span> <span class="n">speed_range</span><span class="p">,</span>
                <span class="s2">&quot;wd&quot;</span><span class="p">:</span> <span class="n">results</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;log_dec&quot;</span><span class="p">:</span> <span class="n">results</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="s2">&quot;whirl_values&quot;</span><span class="p">:</span> <span class="n">results</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
            <span class="p">},</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">rotor_current_speed</span>

        <span class="k">return</span> <span class="n">results</span></div>

    <span class="k">def</span> <span class="nf">mode_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">kappa_modes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wn</span><span class="p">)):</span>
            <span class="n">kappa_color</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">kappa_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">kappa</span> <span class="ow">in</span> <span class="n">kappa_mode</span><span class="p">:</span>
                <span class="n">kappa_color</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;tab:blue&quot;</span> <span class="k">if</span> <span class="n">kappa</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;tab:red&quot;</span><span class="p">)</span>
            <span class="n">kappa_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kappa_color</span><span class="p">)</span>

        <span class="n">mode_shapes</span> <span class="o">=</span> <span class="n">ModeShapeResults</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evectors</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">],</span>
            <span class="n">new_attributes</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;ndof&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">,</span>
                <span class="s2">&quot;nodes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
                <span class="s2">&quot;nodes_pos&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_pos</span><span class="p">,</span>
                <span class="s2">&quot;elements_length&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements_length</span><span class="p">,</span>
                <span class="s2">&quot;w&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span>
                <span class="s2">&quot;wd&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">wd</span><span class="p">,</span>
                <span class="s2">&quot;log_dec&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_dec</span><span class="p">,</span>
                <span class="s2">&quot;kappa_modes&quot;</span><span class="p">:</span> <span class="n">kappa_modes</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">mode_shapes</span>

<div class="viewcode-block" id="Rotor.plot_ucs"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.plot_ucs">[docs]</a>    <span class="k">def</span> <span class="nf">plot_ucs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stiffness_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot undamped critical speed map.</span>

<span class="sd">        This method will plot the undamped critical speed map for a given range</span>
<span class="sd">        of stiffness values. If the range is not provided, the bearing</span>
<span class="sd">        stiffness at rated speed will be used to create a range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stiffness_range : tuple, optional</span>
<span class="sd">            Tuple with (start, end) for stiffness range.</span>
<span class="sd">        num : int</span>
<span class="sd">            Number of steps in the range.</span>
<span class="sd">            Default is 20.</span>
<span class="sd">        ax : matplotlib axes, optional</span>
<span class="sd">            Axes in which the plot will be drawn.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : matplotlib axes</span>
<span class="sd">            Returns the axes object with the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">stiffness_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rated_w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bearing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bearing_seal_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">bearing</span><span class="o">.</span><span class="n">kxx</span><span class="o">.</span><span class="n">interpolated</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rated_w</span><span class="p">)</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                <span class="n">stiffness_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stiffness_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>

        <span class="n">stiffness_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">*</span><span class="n">stiffness_range</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">)</span>
        <span class="n">rotor_wn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stiffness_log</span><span class="p">)))</span>

        <span class="n">bearings_elements</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># exclude the seals</span>
        <span class="k">for</span> <span class="n">bearing</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bearing_seal_elements</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">bearing</span><span class="p">)</span> <span class="o">==</span> <span class="n">BearingElement</span><span class="p">:</span>
                <span class="n">bearings_elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bearing</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stiffness_log</span><span class="p">):</span>
            <span class="n">bearings</span> <span class="o">=</span> <span class="p">[</span><span class="n">BearingElement</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">kxx</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">cxx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bearings_elements</span><span class="p">]</span>
            <span class="n">rotor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shaft_elements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">disk_elements</span><span class="p">,</span> <span class="n">bearings</span><span class="p">,</span> <span class="n">n_eigen</span><span class="o">=</span><span class="mi">16</span>
            <span class="p">)</span>
            <span class="n">rotor_wn</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotor</span><span class="o">.</span><span class="n">wn</span><span class="p">[:</span><span class="mi">8</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_prop_cycle</span><span class="p">(</span><span class="n">cycler</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="n">seaborn_colors</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">stiffness_log</span><span class="p">,</span> <span class="n">rotor_wn</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Bearing Stiffness (N/m)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Critical Speed (rad/s)&quot;</span><span class="p">)</span>

        <span class="n">bearing0</span> <span class="o">=</span> <span class="n">bearings_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">bearing0</span><span class="o">.</span><span class="n">kxx</span><span class="o">.</span><span class="n">interpolated</span><span class="p">(</span><span class="n">bearing0</span><span class="o">.</span><span class="n">w</span><span class="p">),</span>
            <span class="n">bearing0</span><span class="o">.</span><span class="n">w</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
            <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;kxx&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">bearing0</span><span class="o">.</span><span class="n">kyy</span><span class="o">.</span><span class="n">interpolated</span><span class="p">(</span><span class="n">bearing0</span><span class="o">.</span><span class="n">w</span><span class="p">),</span>
            <span class="n">bearing0</span><span class="o">.</span><span class="n">w</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
            <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;kyy&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Rotor.plot_level1"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.plot_level1">[docs]</a>    <span class="k">def</span> <span class="nf">plot_level1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stiffness_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot level 1 stability analysis.</span>

<span class="sd">        This method will plot the stability 1 analysis for a</span>
<span class="sd">        given stiffness range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stiffness_range : tuple, optional</span>
<span class="sd">            Tuple with (start, end) for stiffness range.</span>
<span class="sd">        num : int</span>
<span class="sd">            Number of steps in the range.</span>
<span class="sd">            Default is 5.</span>
<span class="sd">        ax : matplotlib axes, optional</span>
<span class="sd">            Axes in which the plot will be drawn.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : matplotlib axes</span>
<span class="sd">            Returns the axes object with the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="n">stiffness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">stiffness_range</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

        <span class="n">log_dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stiffness</span><span class="p">))</span>

        <span class="c1"># set rotor speed to mcs</span>
        <span class="n">speed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rated_w</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">Q</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stiffness</span><span class="p">):</span>
            <span class="n">bearings</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bearing_seal_elements</span><span class="p">]</span>
            <span class="n">cross_coupling</span> <span class="o">=</span> <span class="n">BearingElement</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">kxx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">cxx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kxy</span><span class="o">=</span><span class="n">Q</span><span class="p">,</span> <span class="n">kyx</span><span class="o">=-</span><span class="n">Q</span><span class="p">)</span>
            <span class="n">bearings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cross_coupling</span><span class="p">)</span>

            <span class="n">rotor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shaft_elements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">disk_elements</span><span class="p">,</span> <span class="n">bearings</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">speed</span>
            <span class="p">)</span>

            <span class="n">non_backward</span> <span class="o">=</span> <span class="n">rotor</span><span class="o">.</span><span class="n">whirl_direction</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;Backward&quot;</span>
            <span class="n">log_dec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotor</span><span class="o">.</span><span class="n">log_dec</span><span class="p">[</span><span class="n">non_backward</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">stiffness</span><span class="p">,</span> <span class="n">log_dec</span><span class="p">,</span> <span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Applied Cross Coupled Stiffness, Q (N/m)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Log Dec&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Rotor.plot_time_response"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.plot_time_response">[docs]</a>    <span class="k">def</span> <span class="nf">plot_time_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dof</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the time response.</span>

<span class="sd">        This function will take a rotor object and plot its time response</span>
<span class="sd">        given a force and a time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        F : array</span>
<span class="sd">            Force array (needs to have the same number of rows as time array).</span>
<span class="sd">            Each column corresponds to a dof and each row to a time.</span>
<span class="sd">        t : array</span>
<span class="sd">            Time array.</span>
<span class="sd">        dof : int</span>
<span class="sd">            Degree of freedom that will be observed.</span>
<span class="sd">        ax : matplotlib axes, optional</span>
<span class="sd">            Axes in which the plot will be drawn.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : matplotlib axes</span>
<span class="sd">            Returns the axes object with the plot.</span>

<span class="sd">        Examples:</span>
<span class="sd">        ---------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t_</span><span class="p">,</span> <span class="n">yout</span><span class="p">,</span> <span class="n">xout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_response</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">yout</span><span class="p">[:,</span> <span class="n">dof</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">dof</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">obs_dof</span> <span class="o">=</span> <span class="s2">&quot;$x$&quot;</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="s2">&quot;m&quot;</span>
        <span class="k">elif</span> <span class="n">dof</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">obs_dof</span> <span class="o">=</span> <span class="s2">&quot;$y$&quot;</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="s2">&quot;m&quot;</span>
        <span class="k">elif</span> <span class="n">dof</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">obs_dof</span> <span class="o">=</span> <span class="s2">&quot;$</span><span class="se">\a</span><span class="s2">lpha$&quot;</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obs_dof</span> <span class="o">=</span> <span class="s2">&quot;$</span><span class="se">\b</span><span class="s2">eta$&quot;</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="s2">&quot;rad&quot;</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Amplitude (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">amp</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
            <span class="s2">&quot;Response for node </span><span class="si">%s</span><span class="s2"> and degree of freedom </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dof</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="n">obs_dof</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Rotor.save_mat"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.save_mat">[docs]</a>    <span class="k">def</span> <span class="nf">save_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save matrices and rotor model to a .mat file.&quot;&quot;&quot;</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;M&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">(),</span>
            <span class="s2">&quot;K&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(),</span>
            <span class="s2">&quot;C&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">(),</span>
            <span class="s2">&quot;G&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">(),</span>
            <span class="s2">&quot;nodes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_pos</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">sio</span><span class="o">.</span><span class="n">savemat</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/</span><span class="si">%s</span><span class="s2">.mat&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">file_name</span><span class="p">),</span> <span class="n">dic</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rotor.save"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save rotor to binary file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_name : str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rotor.load"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.Rotor.load">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load rotor from binary file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_name : str</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotor : ross.rotor.Rotor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="rotor_example"><a class="viewcode-back" href="../../api.html#ross.rotor_assembly.rotor_example">[docs]</a><span class="k">def</span> <span class="nf">rotor_example</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;This function returns an instance of a simple rotor with</span>
<span class="sd">    two shaft elements, one disk and two simple bearings.</span>
<span class="sd">    The purpose of this is to make available a simple model</span>
<span class="sd">    so that doctest can be written using this.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    An instance of a rotor object.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; rotor = rotor_example()</span>
<span class="sd">    &gt;&gt;&gt; np.round(rotor.wd[:4])</span>
<span class="sd">    array([  83.,   87.,  255.,  274.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#  Rotor without damping with 2 shaft elements 1 disk and 2 bearings</span>
    <span class="n">i_d</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">o_d</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.25</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="n">shaft_elem</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">ShaftElement</span><span class="p">(</span>
            <span class="n">l</span><span class="p">,</span> <span class="n">i_d</span><span class="p">,</span> <span class="n">o_d</span><span class="p">,</span> <span class="n">steel</span><span class="p">,</span> <span class="n">shear_effects</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rotary_inertia</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">gyroscopic</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">L</span>
    <span class="p">]</span>

    <span class="n">disk0</span> <span class="o">=</span> <span class="n">DiskElement</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">steel</span><span class="p">,</span> <span class="mf">0.07</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.28</span><span class="p">)</span>
    <span class="n">disk1</span> <span class="o">=</span> <span class="n">DiskElement</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">steel</span><span class="p">,</span> <span class="mf">0.07</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">)</span>

    <span class="n">stfx</span> <span class="o">=</span> <span class="mf">1e6</span>
    <span class="n">stfy</span> <span class="o">=</span> <span class="mf">0.8e6</span>
    <span class="n">bearing0</span> <span class="o">=</span> <span class="n">BearingElement</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">kxx</span><span class="o">=</span><span class="n">stfx</span><span class="p">,</span> <span class="n">kyy</span><span class="o">=</span><span class="n">stfy</span><span class="p">,</span> <span class="n">cxx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">bearing1</span> <span class="o">=</span> <span class="n">BearingElement</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">kxx</span><span class="o">=</span><span class="n">stfx</span><span class="p">,</span> <span class="n">kyy</span><span class="o">=</span><span class="n">stfy</span><span class="p">,</span> <span class="n">cxx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Rotor</span><span class="p">(</span><span class="n">shaft_elem</span><span class="p">,</span> <span class="p">[</span><span class="n">disk0</span><span class="p">,</span> <span class="n">disk1</span><span class="p">],</span> <span class="p">[</span><span class="n">bearing0</span><span class="p">,</span> <span class="n">bearing1</span><span class="p">])</span></div>


<span class="k">def</span> <span class="nf">MAC</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;MAC for two vectors&quot;&quot;&quot;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">((</span><span class="n">H</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">@</span> <span class="n">v</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">((</span><span class="n">H</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">@</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">@</span> <span class="n">v</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">MAC_modes</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;MAC for multiple vectors&quot;&quot;&quot;</span>
    <span class="c1"># n is the number of modes to be evaluated</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">macs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">[:</span><span class="n">n</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">[:</span><span class="n">n</span><span class="p">]):</span>
            <span class="n">macs</span><span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">MAC</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">plot</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">macs</span>

    <span class="n">xpos</span><span class="p">,</span> <span class="n">ypos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">xpos</span><span class="p">,</span> <span class="n">ypos</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">xpos</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">ypos</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">zpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xpos</span><span class="p">)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">xpos</span><span class="p">)</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">xpos</span><span class="p">)</span>
    <span class="n">dz</span> <span class="o">=</span> <span class="n">macs</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="c1"># fig.suptitle(&#39;MAC - %s vs %s&#39; % (U.name, V.name), fontsize=12)</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">bar3d</span><span class="p">(</span>
        <span class="n">xpos</span><span class="p">,</span> <span class="n">ypos</span><span class="p">,</span> <span class="n">zpos</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">(</span><span class="n">dz</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">zsort</span><span class="o">=</span><span class="s2">&quot;max&quot;</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># ax.set_xlabel(&#39;%s  modes&#39; % U.name)</span>
    <span class="c1"># ax.set_ylabel(&#39;%s  modes&#39; % V.name)</span>

    <span class="n">sm</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1"># fake up the array of the scalar mappable</span>
    <span class="n">sm</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cbar</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s2">&quot;MAC&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">macs</span>


<span class="k">def</span> <span class="nf">whirl</span><span class="p">(</span><span class="n">kappa_mode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluates the whirl of a mode&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">kappa</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">1e-3</span> <span class="k">for</span> <span class="n">kappa</span> <span class="ow">in</span> <span class="n">kappa_mode</span><span class="p">):</span>
        <span class="n">whirldir</span> <span class="o">=</span> <span class="s2">&quot;Forward&quot;</span>
    <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">kappa</span> <span class="o">&lt;=</span> <span class="mf">1e-3</span> <span class="k">for</span> <span class="n">kappa</span> <span class="ow">in</span> <span class="n">kappa_mode</span><span class="p">):</span>
        <span class="n">whirldir</span> <span class="o">=</span> <span class="s2">&quot;Backward&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">whirldir</span> <span class="o">=</span> <span class="s2">&quot;Mixed&quot;</span>
    <span class="k">return</span> <span class="n">whirldir</span>


<span class="nd">@np</span><span class="o">.</span><span class="n">vectorize</span>
<span class="k">def</span> <span class="nf">whirl_to_cmap</span><span class="p">(</span><span class="n">whirl</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Maps the whirl to a value&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">whirl</span> <span class="o">==</span> <span class="s2">&quot;Forward&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">whirl</span> <span class="o">==</span> <span class="s2">&quot;Backward&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.5</span>
</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Team Ross.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>
  </body>
</html>